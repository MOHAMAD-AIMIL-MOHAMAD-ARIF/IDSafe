// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

// prisma/schema.prisma

generator client {
  provider = "prisma-client" // Prisma 7 client
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

/**
 * ========= Enums (from data dictionary) =========
 */
// USER.role values: END_USER, ADMIN
// USER.status values: ACTIVE, LOCKED, DEACTIVATED
enum UserRole {
  END_USER
  ADMIN
}

enum UserStatus {
  ACTIVE
  LOCKED
  DEACTIVATED
}

/**
 * ========= USER =========
 */

model User {
  userId      Int        @id @default(autoincrement())
  email       String     @unique
  role        UserRole
  status      UserStatus
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  lastLoginAt DateTime?

  // Relations
  webauthnCredentials WebauthnCredential[]
  vaultEntries        VaultEntry[]
  recoveryData        RecoveryData?
  recoveryTokens      RecoveryToken[]
  auditLogsAsSubject  AuditLog[]           @relation("AuditLogSubject")
  auditLogsAsActor    AuditLog[]           @relation("AuditLogActor")
  updatedConfigs      SystemConfig[]
  deviceKeys          DeviceKey[]
  adminCredential     AdminCredential?
}

/**
 * ========= WEBAUTHN_CREDENTIAL =========
 */
// WEBAUTHN_CREDENTIAL table :contentReference[oaicite:1]{index=1}

model WebauthnCredential {
  credentialId Int  @id @default(autoincrement())
  userId       Int
  user         User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  externalCredentialId String    @unique
  publicKey            String
  aaguid               String
  attestationFormat    String
  signCount            Int       @default(0)
  isActive             Boolean   @default(true)
  createdAt            DateTime  @default(now())
  lastUsedAt           DateTime?

  @@index([userId])
}

/**
 * ========= VAULT_ENTRY =========
 */
// VAULT_ENTRY table :contentReference[oaicite:2]{index=2}

model VaultEntry {
  entryId Int  @id @default(autoincrement())
  userId  Int
  user    User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  ciphertextBlob String
  iv             String
  authTag        String
  metadataJson   Json?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now())
  deletedAt DateTime?
  isDeleted Boolean   @default(false)

  @@index([userId])
}

/**
 * ========= RECOVERY_DATA =========
 */
// One-to-one with USER (user_id UNIQUE) :contentReference[oaicite:3]{index=3}

model RecoveryData {
  recoveryId Int  @id @default(autoincrement())
  userId     Int  @unique
  user       User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  wrappedVaultKey String
  kdfSalt         String
  kdfAlgorithm    String
  kdfTimeCost     Int
  kdfMemoryCost   Int
  kdfParallelism  Int

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())
}

/**
 * ========= RECOVERY_TOKEN =========
 */
// Recovery / magic-link tokens :contentReference[oaicite:4]{index=4}

model RecoveryToken {
  tokenId Int  @id @default(autoincrement())
  userId  Int
  user    User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  tokenHash String    @unique
  tokenType String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([userId])
}

/**
 * ========= AUDIT_LOG =========
 */
// AUDIT_LOG has two optional FKs to USER: user_id (subject), actor_id (actor) :contentReference[oaicite:5]{index=5}

model AuditLog {
  logId Int @id @default(autoincrement())

  userId  Int?
  subject User? @relation("AuditLogSubject", fields: [userId], references: [userId], onDelete: SetNull)

  actorId Int?
  actor   User? @relation("AuditLogActor", fields: [actorId], references: [userId], onDelete: SetNull)

  eventType   String
  ipAddress   String?
  userAgent   String?
  detailsJson Json?
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([actorId])
}

/**
 * ========= SYSTEM_CONFIG =========
 */
// SYSTEM_CONFIG table with FK updated_by_user_id → USER.user_id :contentReference[oaicite:6]{index=6}

model SystemConfig {
  configKey   String   @id
  configValue String
  description String?
  updatedAt   DateTime @default(now())

  updatedByUserId Int?
  updatedByUser   User? @relation(fields: [updatedByUserId], references: [userId], onDelete: SetNull)

  @@index([updatedByUserId])
}

/**
 * ========= DEVICE_KEY =========
 */
/**
 * Each physical device has its own public key.
 * The DEK (vault key) is wrapped per device.
 * Unwrapping the DEK requires the device’s private key stored in IndexedDB.
 */

model DeviceKey {
  deviceId Int @id @default(autoincrement())

  userId Int
  user   User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  devicePublicKey String // JWK or base64-encoded public key
  deviceLabel     String? // Optional: "Laptop", "iPhone", etc.

  wrappedDEK String // DEK encrypted with this device’s public key

  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?

  @@index([userId])
}

/**
 * ========= AdminCredential =========
 */
model AdminCredential {
  adminCredentialId Int @id @default(autoincrement())

  userId Int  @unique
  user   User @relation(fields: [userId], references: [userId], onDelete: Cascade)

  // Email is the username, so no "username" column needed.
  passwordHash String
  passwordAlgo String @default("argon2id")

  // Optional lockout controls (good for security + easy to implement)
  failedAttempts Int       @default(0)
  lockedUntil    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
